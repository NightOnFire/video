<?php
<<<<<<< HEAD
/**
 * @file video.module
 *
 * @author Heshan Wanigasooriya <heshan at heidisoft dot com>
 *                              <heshanmw at gmail dot com>
 * @todo
 */
/**
 * Let's include views logic if views module is enabled
*/
if (module_exists('views')) {
  module_load_include('inc', 'video', 'views_video');
}

/********************************************************************
 * General Hooks
 ********************************************************************/

/**
 * Help hook
 * Implementation of hook_help
 * @param $section
 *   string of the area of Drupal where help was requested
=======

/**
 *
 * @file video.module
>>>>>>> 7.x-1.x
 *
 */
<<<<<<< HEAD

function video_help($path, $arg) {
  switch ($path) {
    case 'admin/help#video':
      $output = '<p>'. t('The Video Module is used to create and administrator Video nodes for Drupal') .'</p>';
      return $output;
  }
}

/**
 * Implementation of hook_menu().
 *
 * @param $may_cache
 *   boolean indicating whether cacheable menu items should be returned
 *
 * @return
 *   array of menu information
 */
function video_menu() {
  global $user;  
  $items = array();

    $items['video'] = array(
      'title' => 'videos',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('video_page'),
      'access arguments' => array('access video'),
      'type' => MENU_SUGGESTED_ITEM);
      
    $items['video/feed'] = array(
      'title' => 'videos feed',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('video_feed'),
      'access arguments' => array('access video'),
      'type' => MENU_CALLBACK);


    $items["node/add/video"] = array(
      'title' => 'Video',
      'description' => 'Allow a variety of video formats to be posted as nodes in your site',
      'page callback' => 'video_add',
      'access arguments' => array('create video'));
        
    $items['admin/settings/video'] = array(
      'title' => 'Video',
      'description' => 'Configure different aspects of the video module and its plugins',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('video_settings_form'),
      'access arguments' => array('administer video'),
      'type' => MENU_NORMAL_ITEM,
    );

    if (arg(0) == 'node' && is_numeric(arg(1))) {
      if ($node = node_load(arg(1)) and $node->type == 'video') {

        //enable the download tab only if it is supported
        if (video_support_download($node)) {
          
          $menu_type = (variable_get('video_displaydownloadmenutab', 1)) ? MENU_LOCAL_TASK : MENU_CALLBACK;
          $items['node/'.$node->nid.'/download'] = array(
            'title' => 'Download',
            'page callback' => 'video_download',
            'page arguments' => array($node),
            'access arguments' => array('access video') && node_access('view', $node, $user->uid),
            'weight' => 5,
            'type' => $menu_type);
        }
      }
    }
  return $items;
}
=======
defined('VIDEO_RENDERING_PENDING') ||
    define('VIDEO_RENDERING_PENDING', 1);
defined('VIDEO_RENDERING_INQUEUE') ||
    define('VIDEO_RENDERING_INQUEUE', 2);
defined('VIDEO_RENDERING_ACTIVE') ||
    define('VIDEO_RENDERING_ACTIVE', 5);
defined('VIDEO_RENDERING_COMPLETE') ||
    define('VIDEO_RENDERING_COMPLETE', 10);
defined('VIDEO_RENDERING_FAILED') ||
    define('VIDEO_RENDERING_FAILED', 20);

// include the field element
module_load_include('inc', 'video', 'video.field');
module_load_include('inc', 'video', 'video.features');
>>>>>>> 7.x-1.x

/*
 * Implementation of hook_init().
 */

function video_init() {
  drupal_add_css(drupal_get_path('module', 'video') . '/css/video.css');
  drupal_add_js(drupal_get_path('module', 'video') . '/js/video.js');
}

/**
 * Implementation of hook_permission().
 */
function video_permission() {
  $perms = array(
    'bypass conversion video' => array(
      'title' => t('Bypass video conversion'),
      'description' => t('Warning: Give to trusted roles only; this permission has security implications.'),
    ),
    'convert on submission' => array(
      'title' => t('Convert video on submit'),
      'description' => t('Warning: Give to trusted roles only; this permission has security implications.'),
    ),
    'override player dimensions' => array(
      'title' => t('Change default player dimentions'),
      'description' => t('Warning: Give to trusted roles only; this permission has usability implications.'),
    ),
    'use default thumb' => array(
      'title' => t('Use default thumbnail'),
    ),
    're convert video' => array(
      'title' => t('Re queue video'),
    ),
    'administer video presets' => array(
      'title' => t('Administer video presets'),
      'description' => t('Perform administration tasks for the video presets.'),
    ),
  );
  return $perms;
}

/**
 * Implementation of hook_theme().
 */
<<<<<<< HEAD
function video_settings_form() {
  global $base_url;

  $form = array();
  
  $form['menu'] = array(
    '#type' => 'fieldset',
    '#title' => t('General behavior'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE
  );
  
  $vtypes = video_get_types_infos();

  if ($vtypes) { // no vtype available
    $video_types = array();
    foreach ($vtypes as $vtype => $info) {
      $video_types[$vtype] = $info['#name'];
    }
    $video_types[0] = t('No default type');
    $form['menu']['video_default_video_type'] = array(
        '#type' => 'select',
        '#title' => t('Choose default video type'),
        '#default_value' => variable_get('video_default_video_type', 0),
        '#description' => t('For installations that have more than one video type available, this sets the default video type when a user visits node/add/video'),
        '#options' => $video_types,
      );
  }

  $form['menu']['video_displaydownloadmenutab'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display download menu tab'),
    '#default_value' => variable_get('video_displaydownloadmenutab', 1),
    '#description' => t('Toggle display of menu tab to download video from the node page.')
  );
  $form['menu']['video_displaydownloadlink'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display download link'),
    '#default_value' => variable_get('video_displaydownloadlink', 1),
    '#description' => t('Toggle display of "download" link (below the node content in most themes).')
  );
  $form['menu']['video_displayplaytime'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display playtime'),
    '#default_value' => variable_get('video_displayplaytime', 1),
    '#description' => t('Toggle the display of the playtime for a video.')
  );
  $form['menu']['video_displayfilesize'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display filesize'),
    '#default_value' => variable_get('video_displayfilesize', 1),
    '#description' => t('Toggle the display of the filesize for a video.')
=======
function video_theme() {
  $theme = array();
  $theme['video'] = array(
    'variables' => array('item' => NULL, 'path' => NULL, 'video_style' => NULL, 'entity' => NULL, 'field' => NULL, 'instance' => NULL),
    'file' => 'video_formatter.inc',
>>>>>>> 7.x-1.x
  );
  $theme['video_thumbnail'] = array(
    'variables' => array('item' => NULL, 'path' => NULL, 'video_style' => NULL, 'entity' => NULL, 'field' => NULL, 'instance' => NULL),
    'file' => 'video_formatter.inc',
  );

  $theme['video_thumbnails'] = array(
    'variables' => array('file' => NULL, 'alt' => '', 'title' => '', 'attributes' => NULL, 'getsize' => TRUE),
    'file' => 'video.theme.inc',
  );
  $theme['video_widget'] = array(
    'render element' => 'element',
    'file' => 'video.theme.inc',
  );
  $theme['video_widget_preview'] = array(
    'variables' => array('item' => TRUE),
    'file' => 'video.theme.inc',
  );
  $theme['video_image'] = array(
    'variables' => array('file' => NULL, 'alt' => '', 'title' => '', 'attributes' => NULL, 'getsize' => TRUE, 'imagecache' => NULL),
    'file' => 'video.theme.inc',
  );
  $theme['video_widget_video_thumb'] = array(
    'variables' => array('item' => TRUE),
    'file' => 'video.theme.inc',
  );

  //$theme['video_formatter_video_colorbox'] = array(
  //  'arguments' => array('element' => NULL, 'imagecache' => NULL),
  //  'file' => 'video_formatter.inc',
  //);
  $theme['video_formatter_video_media_js'] = array(
    'variables' => array('element' => NULL),
    'file' => 'video_formatter.inc',
  );
  $theme['video_encoding_failed'] = array(
    'variables' => array(),
    'file' => 'video_formatter.inc',
  );
  $theme['video_inprogress'] = array(
    'variables' => array(),
    'file' => 'video_formatter.inc',
  );

  $path = drupal_get_path('module', 'video') . '/theme';
  //Lets setup our themes for our players
  $players = video_video_players();
  foreach ($players as $tpl => $value) {
    $theme[$tpl] = array(
      'variables' => array('video' => NULL, 'themed_output' => NULL),
      'template' => str_replace('_', '-', $tpl),
      'path' => $path,
    );
  }
  //We need to add an flv theme buffer to allow users to override in their own module to add in extra parameters before
  //calling our flv template file.
  $theme['video_flv'] = array(
    'variables' => array('video' => NULL, 'node' => NULL),
    'file' => 'video_formatter.inc'
  );
  // @TODO : check is there any other optimal way to do this?
  $theme['video_formatter'] = array(
    'variables' => array('item' => NULL, 'path' => NULL, 'video_style' => NULL, 'entity' => NULL, 'field' => NULL, 'instance' => NULL),
    'file' => 'video_formatter.inc'
  );
  return $theme;
}

/*
 * Implmentation of hook_cron().
 */

function video_cron() {
  if (variable_get('video_cron', TRUE)) {
    module_load_include('inc', 'video', 'includes/conversion');
    $video_conversion = new video_conversion;
    if ($videos = $video_conversion->load_job_queue()) {
      $queue = DrupalQueue::get('video_queue');
      foreach ($videos as $video) {
        if ($queue->createItem($video)) {
          $video_conversion->change_status($video->vid, VIDEO_RENDERING_INQUEUE);
        }
      }
<<<<<<< HEAD
      return array($enclosure, $mrss);

    case 'revision delete':
      db_query('DELETE FROM {video} WHERE vid = %d', $node->vid);
      break;
  }
}


/**
 * Create video submission page. Let the user select the actived video types
 * or display the video form for the selected video type
*/
function video_add() {
  global $user;
 
  $edit = isset($_POST['edit']) ? $_POST['edit'] : '';

  // If a video type has been specified, validate its existence.

  $vtypes = video_get_types();

  if (arg(3) && in_array(arg(3), $vtypes)) { // is a valid video type
    $type = arg(3);

    // Initialize settings:
    module_load_include('inc', 'node', 'node.pages');
    $node = (object) array('uid' => $user->uid, 'name' => $user->name, 'type' => 'video', 'vtype' => $type);
    $output = drupal_get_form('video_node_form', $node);
    drupal_set_title(t('Submit %name video', array('%name' => $type)));
  }
  else if (count($vtypes) == 1) { // only one vtype active. redirect the user to the active type form
    // Initialize settings:
    $node = (object) array('uid' => $user->uid, 'name' => $user->name, 'type' => 'video', 'vtype' => $vtypes[0]);
    module_load_include('inc', 'node', 'node.pages');
    $output = drupal_get_form('video_node_form', $node);
    drupal_set_title(t('Submit %name video', array('%name' => $vtypes[0])));
  }
  else if ($vtype = variable_get('video_default_video_type', 0)) {
    // Initialize settings:
    $node = (object) array('uid' => $user->uid, 'name' => $user->name, 'type' => 'video', 'vtype' => $vtype);
    module_load_include('inc', 'node', 'node.pages');
    $output = drupal_get_form('video_node_form', $node);
    drupal_set_title(t('Submit %name video', array('%name' => $vtype)));
  }
  else {
    $output = video_types_page();
  }
  return $output;
}


/**
 * Display a video types selection page
*/
function video_types_page() {

  drupal_set_title(t('Submit Video')); // we have to set a titl ebecause the node module will not do it for us as we are using a callback video_add()

  $vtypes = video_get_types_infos();
  if(!$vtypes) { // no vtype available
    return t('There are no Video types enabled.');
  }
  else {
    $items = array();
    foreach ($vtypes as $vtype => $infos) {
      $out = '<dt>'. l($infos['#name'], "node/add/video/$vtype", array('HTML'=>TRUE, 'attributes' => array('title' => 'Add a '. $infos['#name']))) .'</dt>';
      $out .= '<dd>'. $infos['#description'] .'</dd>';
      $items[$vtype] = $out;
=======
>>>>>>> 7.x-1.x
    }
  }
}

/**
 * Implmentation of hook_cron_queue_info()
 */
function video_cron_queue_info() {
  $queues['video_queue'] = array(
    'worker callback' => 'video_queue_process',
    'time' => variable_get('video_queue_timeout', 90),
  );
  return $queues;
}

/**
 * Process video transcoding queue
 */
function video_queue_process($video) {
  module_load_include('inc', 'video', 'includes/conversion');
  $video_conversion = new video_conversion;
  $video_conversion->process($video);
}

/*
 * Utility function that will add a preview of thumbnails for you to select when uploading videos.
 */

<<<<<<< HEAD
  $form['video'] = array('#type' => 'fieldset', '#title' => t('Video Information'), '#weight' => -19);
  
  if(!video_support_autoresolution($node)) { // this vtype doesn't support autoresolution
    // let's display the resolution selection
    $form['video']['vresolution'] = array(
      '#type' => 'select',
      '#title' => t('Resolution'),
      '#description' => t("Select the approriate resolution (aspect ratio) for your video.<br />If you don't know what to choose then the default value will probably be ok for you."),
      '#options' => _video_get_resolution_options(),
      '#default_value' => _video_get_resolution_selected_option($node),
      '#required' => true,
    );
  }
  else {
  // set an hidden field to store video resolution
    $form['hvresolution'] = array(
      '#type' => 'hidden',
      '#value' => $node->videox . 'x' . $node->videoy
    );
  }
  
  if(!video_support_autoplaytime($node)) { // this vtype doesn't support autoplaytime
    $form['video']['playtime'] = array(
      '#type' => 'fieldset',
      '#title' => t('Playtime'),
      '#collapsible' => true,
      '#collapsed' => ($node->playtime_seconds) ? false : true, // display expanded if we have values inserted by the user
      '#description' => t('Insert here the duration of the video.<br />Values may be entered in excess of their normal "clock maximum" (the seconds field may be 3600 to represent 1 hour), however each value will be summed for a total of all three.'));
    $playtime = _video_sec2hms($node->playtime_seconds);
    $form['video']['playtime']['playtime_hours'] = array(
      '#type' => 'textfield',
      '#title' => t('Hours'),
      '#size' => 11,
      '#maxlength' => 11,
      '#default_value' => $playtime['hours'],
    );
    $form['video']['playtime']['playtime_minutes'] = array(
      '#type' => 'textfield',
      '#title' => t('Minutes'),
      '#size' => 11,
      '#maxlength' => 11,
      '#default_value' => $playtime['minutes'],
    );
    $form['video']['playtime']['playtime_seconds'] = array(
      '#type' => 'textfield',
      '#title' => t('Seconds'),
      '#required' => FALSE,
      '#size' => 11,
      '#maxlength' => 11,
      '#default_value' => $playtime['seconds'],
    );
  }
  else {
  // set an hidden field to store video length
    $form['playtime_seconds'] = array(
      '#type' => 'hidden',
      '#value' => $node->playtime_seconds
    );
   // we need to store file size too
   $form['hsize'] = array(
      '#type' => 'hidden',
      '#value' => $node->size
    );
  }

  // Get the video-type-specific bits.
  $form = module_invoke('video_' . $node->vtype, 'v_form', $node, $form);

  return $form;
}


/**
 * Implementation of hook_validate
 */
function video_validate($node, $form = array()) {
  if(!video_support_autoresolution($node) || $node->vresolution) { // we have some resolution value
    // form api checked for good values of vresolution
    if(variable_get("video_{$node->vresolution}_value", '') == '') {
=======
function video_thumb_process(&$element, &$form_state) {
  // Developed for ffmpeg support
  $file = $element['#value'];
  $delta = $file['fid'];
  $field = field_widget_field($element, $form_state);
  $instance = field_widget_instance($element, $form_state);
  $settings = $instance['widget']['settings'];
  $gen_fail = FALSE;

  if (isset($element['preview']) && $file['fid'] != 0) {
    if (in_array($field['settings']['autothumbnail'], array('auto', 'auto_fallback'))) {
      $default_thumb = array();
      $transcoder = new video_transcoder;
      if ($thumbs = $transcoder->generate_thumbnails($file)) {
        $default_thumb = array_rand($thumbs);
        if (!empty($thumbs)) {
          foreach ($thumbs as $fid => $img) {
            // if file object contain url then use file name to identify object
            $thumbss[$img->fid] = theme('image_style', array('style_name' => $field['settings']['preview_video_thumb_style'], 'path' => $img->uri));
          }
        }
      }
>>>>>>> 7.x-1.x

      if (!empty($thumbss)) {
        $element['thumbanail'] = array(
          '#type' => 'radios',
          '#title' => t('Video thumbnails'),
          '#element_validate' => array('video_thumbnail_validate'),
          '#options' => $thumbss,
          '#default_value' => !empty($file['thumbanail']) ? $file['thumbanail'] : $thumbs[$default_thumb]->fid,
          '#weight' => 10,
          '#attributes' => array('class' => array('video-thumbnails'), 'onchange' => 'videoftp_thumbnail_change()', 'rel' => 'video_large_thumbnail-' . $delta),
        );
      } else {
        $gen_fail = TRUE;
      }
    }
<<<<<<< HEAD
  }

  module_invoke('video_'.$node->vtype, 'v_validate', $node);

}


/**
 * Implementation of hook submit
 */
function video_presave(&$node) {
  if(video_support_autoresolution($node) && ($node->new_video_upload_file_fid)) { // vtype support autoresolution getting
    $xy = module_invoke('video_' . $node->vtype, 'v_auto_resolution', $node);
    if ($xy) {
	  $node->videox = $xy[0];
	  $node->videoy = $xy[1];
    }
  }
  else {
    // if you have a existing value from hidden field
    if($node->hvresolution) {
      $res = explode('x', $node->hvresolution);
      $node->videox = $res[0];
      $node->videoy = $res[1];
      $node->size = $node->hsize;
    }
    // we should have a good value (checked by Form API)
    else {
      $res = explode('x', variable_get('video_resolution_' . $node->vresolution . '_value', ''));
      $node->videox = $res[0];
      $node->videoy = $res[1];
    }
  }  

  if(video_support_autoplaytime($node) && ($node->new_video_upload_file_fid)) { // vtype support auto playtime
    $node->playtime_seconds = module_invoke('video_' . $node->vtype, 'v_auto_playtime', $node);
  }
  else { // vtype does not support auto_playtime
    $node->playtime_seconds += ($node->playtime_hours * 3600) + ($node->playtime_minutes * 60);
=======
    // if fail creating thumbnails fall back to manual or manual upload
    if ((!empty($gen_fail) && $field['settings']['autothumbnail'] == 'auto_fallback') ||
        $field['settings']['autothumbnail'] == 'manual_upload') {
      $element['thumbanail'] = array(
        '#title' => t('Video thumbnail'),
//        '#element_validate' => array('video_thumbnail_validate'),
        '#type' => 'managed_file',
        '#description' => t('The uploaded image will be used as video thumbnail on this video.'),
        '#default_value' => !empty($file['thumbanail']['fid']) && is_integer($file['thumbanail']['fid']) ? $file['thumbanail']['fid'] : NULL,
        '#upload_location' => file_default_scheme() . '://' . variable_get('video_thumb_path', 'videos/thumbnails') . '/' . $file['fid'],
      );
    }
    // if no thumbnail creation
    if ($field['settings']['autothumbnail'] == 'no') {
      $element['thumbanail'] = array(
        '#type' => 'value',
        '#value' => NULL,
      );
    }
    // Setup our large thumbnail that is on the left.
    // @todo Add smaller video preview instead of thumbnail?
    if (isset($file['thumbanail']) && !empty($file['thumbanail'])) {
      $large_thumb = file_load($file['thumbanail']);
    } elseif (!empty($field['settings']['default_video_thumbnail']['fid'])) {
      $large_thumb = file_load($field['settings']['default_video_thumbnail']['fid']);
    } else {
//      $large_thumb = file_load($default_thumb);
    }
//    print_r($field['settings']);
//    $default_thumbnail = file_load($field['settings']['default_video_thumbnail']);
    // @todo Add video player
    if (!empty($large_thumb))
      $element['preview']['#suffix'] = '<div class="video_large_thumbnail-' . $delta . '">' . theme('image_style', array('style_name' => $field['settings']['preview_video_thumb_style'], 'path' => $large_thumb->uri)) . '</div>';
>>>>>>> 7.x-1.x
  }
}

/**
 * Implementation of hook_file_delete().
 */
<<<<<<< HEAD
function video_insert($node) {
  // set the required properties of the video node
  video_presave($node);
  $node->serialized_data = serialize($node->serial_data); //Serialize the data for insertion into the database.

  return db_query("INSERT INTO {video} (vid, nid, vtype, vidfile, size, videox, videoy, video_bitrate, audio_bitrate, audio_sampling_rate, audio_channels, playtime_seconds, disable_multidownload, download_folder, use_play_folder, serialized_data) VALUES (%d, %d, '%s', '%s', %d, %d, %d, %d, %d, %d, '%s', %d, %d, '%s', %d, '%s')",
    $node->vid, $node->nid, $node->vtype, $node->vidfile, $node->size, $node->videox, $node->videoy, $node->video_bitrate, $node->audio_bitrate, $node->audio_sampling_rate, $node->audio_channels, $node->playtime_seconds, $node->disable_multidownload, $node->download_folder, $node->use_play_folder, $node->serialized_data);
=======
function video_file_delete($file) {
  db_delete('video_files')
      ->condition('fid', $file->fid)
      ->execute();
>>>>>>> 7.x-1.x
}

/**
 * Compares passed extensions with normal video web extensions.
 */
<<<<<<< HEAD
function video_update($node) {
  if ($node->revision) { //If a new node revision is being added then insert a new row.
    return video_insert($node);
  }
  else {
    // set the required properties of the video node
    video_presave($node);
    $node->serialized_data = serialize($node->serial_data); //Serialize the data for insertion into the database.

    return db_query("UPDATE {video} SET vidfile='%s', size=%d, videox=%d, videoy=%d, video_bitrate=%d, audio_bitrate=%d, audio_sampling_rate=%d, audio_channels='%s', playtime_seconds=%d, disable_multidownload=%d, download_folder='%s', use_play_folder=%d, serialized_data='%s' WHERE vid = %d",
         $node->vidfile, $node->size, $node->videox, $node->videoy, $node->video_bitrate, $node->audio_bitrate, $node->audio_sampling_rate, $node->audio_channels, $node->playtime_seconds, $node->disable_multidownload, $node->download_folder, $node->use_play_folder, $node->serialized_data, $node->vid);
=======
function video_web_extensions($ext) {
  $extensions = array_filter(explode(' ', $ext));
  $web_extensions = array(
    'mov', 'mp4', '3gp', '3g2', 'mpg', 'mpeg', // quicktime
    'divx', //divx
    'rm', // realplayer
    'flv', 'f4v', //flash player
    'swf', // swf player
    'dir', 'dcr', // dcr player
    'asf', 'wmv', 'avi', 'mpg', 'mpeg', // windows media
    'ogg', 'ogv', 'webm' // ogg/ogv theora
  );
  if (count(array_diff($extensions, $web_extensions))) {
    return FALSE;
>>>>>>> 7.x-1.x
  }
  return TRUE;
}

/**
 * Implementation of hook_views_api().
 */
function video_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'video') . '/views',
  );
}

/**
<<<<<<< HEAD
 * Implementation of hook_load()
 *
 * @param $node
 *   object or boolean FALSE on error
 */
function video_load($node) {

  if (is_numeric($node->vid)) {
    $node = db_fetch_object(db_query("SELECT * FROM {video} WHERE vid = %d", $node->vid));

    // load serialized data for plug-ins
    $node->serial_data = unserialize($node->serialized_data);

    return $node;
=======
 * Process elements loads on settings
 * @param <type> $element
 */
function video_widget_element_settings(&$element, &$form_state) {
  $file = $element['#value'];
  $delta = $element['#delta'];

  $field = field_widget_field($element, $form_state);
  $instance = field_widget_instance($element, $form_state);
  $settings = $instance['settings'];
  // Check if using the default width and replace tokens.
  $default_dimensions = user_access('override player dimensions');
  $description = t('Set your video dimensions.  This will create your player with these dimensions.');
  //setup our default dimensions.
  $dimensions = $settings['default_dimensions'];
  $player_dimensions = $settings['default_player_dimensions'];
  // Lets figure out our dimensions for our video and add astericks next to our options.
  $options = video_explode("\n", variable_get("video_metadata_dimensions", video_default_dimensions()));
  if ($field['settings']['autoconversion'] && isset($element['preview']) &&
      $file['fid'] != 0 && $default_dimensions) {
    $file_object = file_load($file['fid']);
    $video_info = _video_dimensions_options($options, drupal_realpath($file_object->uri));
    $description = t('Set your video dimensions.  This will create your player
      and transcode your video with these dimensions.  Your video size is !size,
      if you choose a higher resolution, this could cause video distortion.
      You are shown dimensions that match your aspect ratio,
      if you choose dimensions that do not match your ratio, we will pad your
      video by adding black bars on either the top or bottom while maintaining
      your videos original aspect ratio.',
            array('!size' => $video_info['width'] . 'x' . $video_info['height']));
    //setup our default display of dimensions.
    //lets go through our options looking for a matching resolution
    foreach ($options as $key => $value) {
      if (stristr($value, t('(Matches Resolution)')) == TRUE) {
        $dimensions = $key;
        break;
      }
    }
>>>>>>> 7.x-1.x
  }
  // Override our dimensions to the user selected.
  if (isset($file['dimensions']) && !empty($file['dimensions'])) {
    $dimensions = $file['dimensions'];
  }

  // Override our player dimensions to the user selected.
  if (isset($file['player_dimensions']) && !empty($file['player_dimensions'])) {
    $player_dimensions = $file['player_dimensions'];
  }

  // show only enabled the autoconversion
  if ($field['settings']['autoconversion']) {
    $element['dimensions'] = array(
      '#type' => 'select',
      '#title' => t('Dimensions for Video Transcoding'),
      '#default_value' => $dimensions,
      '#description' => $description,
      '#options' => $options,
    );
  }
  // get the player dimentions
  $element['player_dimensions'] = array(
    '#type' => 'select',
    '#title' => t('Dimensions for Video Player'),
    '#default_value' => $player_dimensions,
    '#description' => t('WxH of your video player.'),
    '#options' => $options,
  );
  // If users cannot change the default dimensions, lets change this to a value.
  if (!$default_dimensions) {
    $element['dimensions']['#type'] = 'value';
    $element['dimensions']['#value'] = $dimensions;
    $element['player_dimensions']['#type'] = 'value';
    $element['player_dimensions']['#value'] = $player_dimensions;
  }

  // only in preview mode and then create thumbnails
  if ($field['settings']['autoconversion']) {
    // check if already converted or failed
    module_load_include('inc', 'video', '/includes/conversion');
    $video_conversion = new video_conversion;
    $video = $video_conversion->load_job($file['fid']);
    if (user_access('re convert video') && isset($video->video_status) && ($video->video_status == VIDEO_RENDERING_COMPLETE || $video->video_status == VIDEO_RENDERING_FAILED)) {
      $status = array(VIDEO_RENDERING_COMPLETE => 'completed', VIDEO_RENDERING_FAILED => 'failed');
      $element['re_convert_video'] = array(
        '#type' => 'checkbox',
        '#title' => t('Video conversion has been <b>' . $status[$video->video_status] . '!</b>. Re-queue video?.'),
        '#description' => t('This will re-convert your video to output formats when you save, or scheduling it for cron.'),
        '#attributes' => array('class' => array('video-re-convert', 'video-' . $video->video_status)),
      );
    }
    if (user_access('bypass conversion video')) {
      $element['bypass_autoconversion'] = array(
        '#type' => 'checkbox',
        '#title' => t('Bypass auto conversion'),
        '#default_value' => isset($file['bypass_autoconversion']) ? $file['bypass_autoconversion'] : variable_get('video_bypass_conversion', FALSE),
        '#description' => t('This will bypass your auto conversion of videos.'),
        '#attributes' => array('class' => array('video-bypass-auto-conversion')),
      );
    }
    // check this to convert the video on save
    $convert = isset($file['convert_video_on_save']) ? $file['convert_video_on_save'] : variable_get('video_convert_on_save', FALSE);
    if (user_access('convert on submission')) {
      $element['convert_video_on_save'] = array(
        '#type' => 'checkbox',
        '#title' => t('Convert video on save'),
        '#default_value' => $convert,
        '#description' => t('This will convert your video to flv format when you save, instead of scheduling it for cron.'),
        '#attributes' => array('class' => array('video-convert-video-on-save')),
      );
    }
  }

  // use of default thumbnail
  $default_thumb = isset($file['use_default_video_thumb']) ? $file['use_default_video_thumb'] : variable_get('video_use_default_thumb', FALSE);
  if (user_access('use default thumb')) {
    $element['use_default_video_thumb'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use the default thumbnail for this video?'),
      '#default_value' => $default_thumb,
      '#description' => t('This will set a flag for this video to use the default video thumbnail when outputed..'),
      '#attributes' => array('class' => array('video-use-default-video-thumb')),
    );
    if ($default_thumb) {
      $element['use_default_video_thumb']['#attributes']['checked'] = 'checked';
    }
  } else {
    $element['use_default_video_thumb'] = array(
      '#type' => 'value',
      '#value' => $default_thumb,
    );
  }
}

/*
 * Function updates our options list to show matching aspect ratios and if we have a matching resolution.
 * 
 * We will update the options array by reference and return the aspect ratio of the file.
 */

function _video_dimensions_options(&$options, $video) {
  $aspect_ratio = _video_aspect_ratio($video);
  //loop through our options and find matching ratio's and also the exact width/height
  foreach ($options as $key => $value) {
    $wxh = explode('x', $value);
    //lets check our width and height first
    if ($aspect_ratio['width'] == $wxh[0] && $aspect_ratio['height'] == $wxh[1]) {
      $options[$key] = $value . ' ' . t('(Matches Resolution)');
    } else {
      //now lets check our ratio's
      $ratio = number_format($wxh[0] / $wxh[1], 4);
      if ($ratio == $aspect_ratio['ratio']) {
        $options[$key] = $value . ' ' . t('(Matches Ratio)');
      }
    }
  }
  return $aspect_ratio;
}

/*
 * Returns the width/height and aspect ratio of the video
 * 
 * @todo: move this to the transcoder class instead?
 */

function _video_aspect_ratio($video) {
  //lets get our video dimensions from the file
  $transcoder = new video_transcoder;
  $wxh = $transcoder->get_dimensions($video);
  $width = $wxh['width'];
  $height = $wxh['height'];

  if (!$width || !$height) {
    //no width and height found just return.
    watchdog('video_conversion', 'We could not determine the height and width of the video: ' . $video, array(), WATCHDOG_DEBUG);
//    drupal_set_message(t('The system counld not determine the width and height of your video: !video.  If transcoding, the system could have problems.', array('!video' => $video)));
    return;
  }

  //now lets get aspect ratio and compare our options in the select dropdown then add an asterick if any to each option representing a matching aspect ratio.
  $ratio = number_format($width / $height, 4);
  $aspect_ratio = array(
    'width' => $width,
    'height' => $height,
    'ratio' => $ratio,
  );
  return $aspect_ratio;
}

/*
 * Return our list of video extensions and their associated player.
 */

function video_video_extensions() {
  $extensions = array(
    'divx' => 'video_play_divx',
    'mov' => 'video_play_quicktime',
    '3gp' => 'video_play_quicktime',
    '3g2' => 'video_play_quicktime',
    'mp4' => 'video_play_quicktime',
    'rm' => 'video_play_realmedia',
    'f4v' => 'video_play_flv',
    'flv' => 'video_play_flv',
    'swf' => 'video_play_flash',
    'dir' => 'video_play_dcr',
    'dcr' => 'video_play_dcr',
    'asf' => 'video_play_windowsmedia',
    'wmv' => 'video_play_windowsmedia',
    'avi' => 'video_play_windowsmedia',
    'mpg' => 'video_play_windowsmedia',
    'mpeg' => 'video_play_windowsmedia',
    'ogg' => 'video_play_theora',
    'ogv' => 'video_play_theora',
    'webm' => 'video_play_theora'
  );
  return $extensions;
}

/*
 * Return our supported video players.
 */

function video_video_players() {
  $players = array(
    'video_play_html5' => t('HTML5 Player'),
    'video_play_divx' => t('Divx Player'),
    'video_play_quicktime' => t('Quicktime'),
    'video_play_realmedia' => t('Real Media Player'),
    'video_play_flv' => t('FLV Flash Players'),
    'video_play_flash' => t('SWF Flash Player'),
    'video_play_dcr' => t('Director/Shockwave'),
    'video_play_windowsmedia' => t('Windows Media Player'),
    'video_play_theora' => t('Theora Player'),
  );
  return $players;
}

/*
 * Return our possible flash players.
 */

function video_video_flv_players() {
  $options = array();
  if (module_exists('swftools')) {
    $options['swftools'] = t('SWF Tools');
  }
  if (module_exists('flowplayer')) {
    $options['flowplayer'] = t('Flowplayer');
  }
  return $options;
}

/**
 * Get the object for the suitable player for the parameter resource
 */
function video_get_player($variables) {
  // Setup our node object to be passed along with the player.
//  $node = $variables['entity'];
  // Setup our video object
  module_load_include('inc', 'video', '/includes/video_helper');
  $video_helper = new video_helper;
  $video = $video_helper->video_object($variables);
  // Lets spit out our theme based on the extension
  $defaults = video_video_extensions();
  $theme_function = variable_get('video_extension_' . $video->player, $defaults[$video->player]);

  // Lets do some special handling for our flv files to accomdate multiple players.
  if ($theme_function == 'video_play_flv') {
    return theme('video_flv', (array) $video);
  } else {
    return theme($theme_function, (array) $video);
  }
}

function video_default_instance_settings($widget) {
  $form = array();
  // Default video settings.
  $form['default_dimensions'] = array(
    '#type' => 'select',
    '#title' => t('Default Video Resolution Dimensions'),
    '#default_value' => !empty($widget['default_dimensions']) ? $widget['default_dimensions'] : '',
    '#options' => video_explode("\n", variable_get("video_metadata_dimensions", video_default_dimensions())),
    '#description' => t('Default transcoding resolution WIDTHxHEIGHT, in px, that FFMPEG will use to transcode your video files.'),
    '#weight' => 15,
  );
  $form['default_player_dimensions'] = array(
    '#type' => 'select',
    '#title' => t('Default Video Player Dimensions'),
    '#default_value' => !empty($widget['default_player_dimensions']) ? $widget['default_player_dimensions'] : '',
    '#options' => video_explode("\n", variable_get("video_metadata_dimensions", video_default_dimensions())),
    '#description' => t('Default player WIDTHxHEIGHT in px.  This is your actual player dimensions that your video will be playing in.'),
    '#weight' => 16,
  );
  return $form;
}

function video_default_field_settings($settings) {
  $form = array();
  // Default video field settings.
  $form['autoconversion'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable video conversion.'),
    '#description' => t('Use ffmpeg(Default) or Zencoder to automatically convert videos to web compatible types eg. FLV, Please make sure to configure your transcoder settings.'),
    '#default_value' => isset($settings['autoconversion']) ? $settings['autoconversion'] : '',
    '#weight' => 17,
  );

  $thumb_options = array(
    'auto' => 'Automatically generate thumbnails',
    'auto_fallback' => 'Automatically generate thumbnails, with fallback to manual upload if fail',
    'manual_upload' => 'Manually upload a thumbnail',
    'no' => 'Don\'t create thumbnail',
  );

  $form['autothumbnail'] = array(
    '#type' => 'radios',
    '#title' => t('Thumbnail Generation'),
    '#options' => $thumb_options,
    '#description' => t('To use ffmpeg(Default) to create thumbnails, Please make sure to configure your transcoder settings before using ffmpeg to create thumbnails.'),
    '#default_value' => isset($settings['autothumbnail']) ? $settings['autothumbnail'] : 'no',
    '#weight' => 18,
  );

  $form['default_video_thumbnail'] = array(
    '#title' => t('Default video thumbnail'),
    '#type' => 'managed_file',
    '#element_validate' => array('video_field_default_thumbnail_validate'),
    '#description' => t('If use default thumbnanil is selected, this image will be shown on display.'),
    '#default_value' => !empty($settings['default_video_thumbnail']['fid']) ? $settings['default_video_thumbnail']['fid'] : '',
    '#upload_location' => 'public://videos/thumbnails/default',
    '#weight' => 19,
  );
  $form['preview_video_thumb_style'] = array(
    '#title' => t('Preview thumbnail style'),
    '#type' => 'select',
    '#options' => image_style_options(FALSE),
    '#empty_option' => '<' . t('no preview') . '>',
    '#default_value' => !empty($settings['preview_video_thumb_style']) ? $settings['preview_video_thumb_style'] : '',
    '#description' => t('The preview image will be shown while editing the content.'),
    '#weight' => 20,
  );
  return $form;
}

/*
 * #options helper function to set our key=value for the form api.
 */

function video_explode($delimeter, $dimensions) {
  $options = array();
  $values = explode($delimeter, $dimensions);
  foreach ($values as $value) {
    //lets check we have a value and its in the right format
    if (!empty($value) && video_format_right($value)) {
      $options[trim($value)] = trim($value);
    }
  }
  return $options;
}

function video_format_right($value) {
  $format = explode("x", $value);
  if (!isset($format[0]) || !is_numeric(trim($format[0])))
    return false;
  if (!isset($format[1]) || !is_numeric(trim($format[1])))
    return false;
  return true;
}

/*
 * Default video dimensions.
 */

function video_default_dimensions() {
  return "176x144\n352x288\n704x576\n1408x1152\n128x96\n160x120\n320x240\n640x480\n800x600\n1024x768\n1600x1200\n2048x1024\n1280x1024\n2560x2048\n5120x4096\n852x480\n1366x768\n1600x1024\n1920x1200\n2560x1600\n3200x2048\n3840x2400\n6400x4096\n7680x4800\n320x200\n640x350\n852x480\n1280x720\n1920x1080";
}

/*
 * Utility function to remove all files and directories recursively.
 */

function rmdirr($dir) {
  if ($objs = glob($dir . "/*")) {
    foreach ($objs as $obj) {
      is_dir($obj) ? rmdirr($obj) : unlink($obj);
    }
  }
  @rmdir($dir);
}

/**
 * Implementation of hook_features_api()
 *
 */
function video_features_api() {
  return array(
    'video' => array(
      'name' => t('Video Presets'),
      'default_hook' => 'video_default_presets',
      'file' => drupal_get_path('module', 'video') . '/video.features.inc',
    ),
  );
}
